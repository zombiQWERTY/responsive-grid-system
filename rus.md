<article>
Кастомная отзывчивая сетка - один из лучших инструментов для создания уникального дизайна.
Вы можете настроить всё что нужно - количество и ширину колонок, отступы и контрольные точки, 
при достижении которых сетка перестраивается.

К сожалению, большинство людей не использует кастомные системы сеток из-за того, что им не хватает знаний и уверенности в своих силах.

В этой статье я хочу помочь вам обрести знания и веру в себя, они 
вам определенно понадобятся для создания собственной сетки. Надеюсь, что к концу этой статьи
вы отложите фреймворки и попробуете создать собственную сетку в следующем
проекте.

## Что входит в сетку? {#что-входит-в-сетку}

Прежде всего, вам нужно знать три вещи.

**Во-первых, вам нужно спроектировать сетку.**

Вы используете колонки одинаковой или разной ширины? Сколько у вас колонок?
Какая ширина и отступы у колонок?

Вы сможете правильно просчитать параметры сетки только после того, как ответите
на эти вопросы. Чтобы помочь вам, я написал статью о [проектировании сеток][1].

Прочтите её, что бы научиться грамотно проектировать сетки.

**Во-вторых, вам нужно знать, как ваша сетка должна вести себя на экранах разного размера.**

Будете ли вы менять размеры колонок и отступов пропорционально ширине экрана или будете 
менять только ширину колонок, оставляя отступы фиксированными? А может менять
количество колонок в конкретных контрольных точках?

На эти вопросы тоже нужно ответить. Они подскажут вам, как рассчитать ширину колонок
и отступов. Если у вас возникли сомнения, прочтите [статью о проектировании сеток][2].

**В-третьих, понравится ли вам писать классы сетки в разметке?**

Когда заходит речь о сетках, мир фронтенда делится на две фракции.

Одни пишут классы сетки в разметке (такой подход используется, например,
в Bootstrap и Foundation). Я называю это **HTML-сетками**. Их разметка выглядит так: 

    <div class="container">
      <div class="row">
        <div class="col-md-9">Content</div>
        <div class="col-md-3">Sidebar</div>
      </div>
    </div>

Другие создают сетки на CSS. Я называю это **CSS-сетки**.

С CSS-сетками разметка получается проще, чем с HTML-сетками.
Вам не приходится повторяться, размечая визуально похожие части документа.
Также вам не нужно помнить, какие у сетки классы:

    <div class="content-sidebar">
      <div class="content"></div>
      <div class="sidebar"></div>
    </div>
    
С другой стороны, стили в случае с CSS-сетками получаются сложнее.
Нужно хорошенько подумать даже для реализации простой задачи 
(если раньше вы таких сеток не создавали).
 
**Что бы я выбрал?**

Я, как и многие эксперты фронтенда, выбираю CSS-сетки
(но я не смею называть себя экспертом).

Если вам интересно, я написал [статью][3] о том, почему я выбрал
CSS-сетки вместо HTML-сеток. Так же я написал [статью][4],
которая поможет вам перейти с HTML-сеток на CSS-сетки.

(Так много статей читать... :cry:)


В любом случае, вам нужно определиться с тремя вещами,
прежде чем создавать свою сетку. В целом, вот они:

1.  Дизайн сетки
2.  Как сетка ведет себя на разных вьюпортах
3.  Что использовать - CSS-сетку или HTML-сетку?


Мы можем двигаться дальше, только определившись с этими вещами.
В этой статье условия таковы:

1.  Сетка максимальной *ширины в 1140px*, с *12 колонками по 75px* и 
    *отступами в 20px*. (Прочтите [эту статью][2] с советами о том, 
    как получить эти числа)
2.  Когда вьюпорт меняет размеры, колонки должны менять размеры пропорционально,
    в то время как *отступы остаются фиксированными* с шириной 20px. 
    (Прочтите [эту статью][2], что бы понять, почему я выбрал такое поведение).
3.  Я собираюсь создавать *CSS-сетку*. (Прочтите [эту статью][3], 
    что бы понять, почему я рекомендую такой подход).

Итак, давайте начнём!

## Создаем вашу сетку {#создаем-вашу-сетку}

Есть восемь шагов для того, что бы построить сетку. Вот эти шаги: 

1.  Выберите спецификацию для сетки
2.  Установите `box-sizing` в `border-box` 
3.  Создайте контейнер для сетки
4.  рассчитайте ширину колонок
5.  Определите расположение отступов
6.  Создайте сетку для отладки
7.  Внесите изменения в раскладку
8.  Сделайте вашу раскладку адаптивной

Большинство из этих шагов становятся достаточно простыми, как только
вы сделаете их хотя бы раз. Я обстоятельно объясню все, что вам нужно знать 
на каждом шаге.

## Шаг 1: Выберите спецификацию {#шаг-1-выберите-спецификацию}

Вы используете *CSS Grid*, *Flexbox*, или старые добрые *флоаты* в вашей сетке?
Ваши инструкции и детали реализации будут различаться для каждой спецификации.

Из всех трех спецификаций, CSS Grid на сегодняшний день является лучшим инструментов 
для создания сетки (из-за сетки :sunglasses:). К сожалению, поддержка CSS Grid 
оставляет желать лучшего, и мы не можем использовать его прямо сейчас. 
Каждый браузер прячет CSS Grid Layout под флаг, и это значит,
что мы не будет рассматривать его в статье. Я настоятельно рекомендую посмотреть
[работу Рейчел Эндрю (Rachel Andrew)][5], если вам интересен CSS Grid.

Далее, перейдем к Flexbox и флоатам. Инструкции при использовании этих двух
спецификаций похожи, так что вы можете выбрать любую из них и читать статью дальше.
Я буду использовать флоаты, потому что их проще объяснить и они лучше
подходят для новичков.

Если вы выбрали Flexbox, имейте ввиду, что есть несколько нюансов, которые вам 
нужно учесть.

## Шаг 2: Установите box-sizing в border-box {#шаг-2-установите-box-sizing-в-border-box}

Свойство `box-sizing` меняет дефолтные настройки блочной CSS модели, которая
используется браузерами для расчета свойств `width` и `height`. Выставляя `box-sizing`
в `border-box`, мы сильно упрощаем расчет размеров колонок и отступов
(вы увидите это позже).

Вот картинка, которая демонстрирует как `width` вычисляется в зависимости от значений
`box-sizing`<figure>

![Свойство Box-sizing и как оно влияет на расчет ширины][6]<figcaption>
Свойство Box-sizing и как оно влияет на расчет ширины</figcaption></figure>

Обычно я ставлю `box-sizing` в `border-box` для всех элементов на сайте, 
так что расчеты `width` и `height` остаются последовательными (и интуитивно понятными)
по всем направлениям. Вот как я делаю это:

    html {
      box-sizing: border-box;
    }
    
    *,
    *:before,
    *:after {
      box-sizing: inherit;
    }
    
Примечание: если вам нужно более детальное объяснение `box-sizing`, я рекомендую
вам [прочесть эту статью][7].


## Шаг 3: Создайте контейнер для сетки {#шаг-3-создайте-контейнер-для-сетки}

У каждой сетки есть контейнер, который определяет её максимальную ширину.
Как правило, я называю его `.l-wrap`. Префикс `.l-` означает layout, и я использую 
это соглашение по именованию с тех пор, как изучил [SMACSS][8] от 
[Джонатана Снука (Jonathan Snook)][9].

    .l-wrap {
        max-width: 1140px;
        margin-right: auto;
        margin-left: auto;
    }

Примечание: я настоятельно рекомендую использовать относительные единицы типа
`em` или `rem` вместо пикселов для доступности и отзывчивости. В этой статье
я пишу все в пикселах, потому что они проще для понимания.


## Шаг 4: Расcчитайте ширину колонок {#шаг-4-расчитайте-ширину-колонок}

Помните, мы используем флоаты для создания наших колонок и отступов. Когда мы
используем флоаты, у нас есть только пять свойств для этого 
(если вы используете Flexbox, то у вас есть еще несколько); вот эти
пять свойств:

*   width
*   margin-right
*   margin-left
*   padding-right
*   padding-left

Если вы помните, HTML для CSS-сеток выглядит примерно так:
    
    <div class="l-wrap">
      <div class="three-col-grid">
        <div class="grid-item">Grid item</div>
        <div class="grid-item">Grid item</div>
        <div class="grid-item">Grid item</div>
      </div>
    </div>
    

Мы знаем, что в этом HTML сетка имеет всего три колонки в строке. Мы также
знаем, что тут нет дополнительных `<div>` для создания отступов. Это означает:

1.  Мы создаем колонки со свойством `width`
2.  Мы создаем отступы либо со свойством `margin`, либо со свойством `padding`

Если думать о колонках и отступах одновременно, то становится сложнее,
так что давайте предположим, что сперва мы создаем сетку без отступов.

На выходе такая сетка будет похожа на что-то такое:<figure>

![Трех-колоночная сетка без отступов][10]<figcaption>Трех-колоночная 
сетка без отступов</figcaption></figure>

Это тот момент, в котором мы должны сделать немного математических вычислений.
Мы знаем, что сетка имеет максимальную ширину в 1140px, а это означает, что
каждая колонка будет 380px (`1140 ÷ 3`).

    .three-col-grid .grid-item {
      width: 380px;
      float: left;
    }
    

Пока все хорошо. Мы сделали сетку, которая работает отлично на вьюпортах больше
чем 1140px. К сожалению, все ломается, когда вьюпорт меньше, чем 1140px.<figure>

![Сетка ломается, когда вьюпорт меньше 1140px][11]<figcaption>Сетка ломается, 
когда вьюпорт меньше 1140px</figcaption></figure>

Это значит, что мы не можем использовать пикселы в наших расчетах. Нам нужна 
единица, которая перестроится в соответствии с шириной контейнера. Лишь одна
единица может так делать - проценты (`%`). Поэтому, мы пропишем ширину в 
процентах:

    .three-col-grid .grid-item  {
      width: 33.33333%;
      float: left;
    }
    
Полученные код выше  - это простая трех-колоночная сетка без каких-либо отступов. 
Когда браузер меняет размер, эти три колонки сменят размер пропорционально.<figure>

![Три колонки без отступов][12]<figcaption>Три колонки без 
отступов</figcaption></figure>

Еще кое-что, перед тем как мы двинемся дальше. Всякий раз, когда все дочерние
элементы в контейнере имеют обтекание, высота контейнера схлопывается. Этот 
феномен называется [схлопывание флоата][13]. Это как если бы в 
контейнере не было бы никаких дочерних элементов:<figure>

![Схлопывание флоата. Изображение с CSS Tricks][14]<figcaption>Схлопывание 
флоата (изображение с CSS Tricks)</figcaption></figure>

Для того, что бы это исправить, нам нужен clearfix, который выглядит следующим
образом:

    .three-col-grid:after {
      display: table;
      clear: both;
      content: '';
    }
    

Если вы используете препроцессор типа Sass, вы можете сделать из этого 
примесь, которая позволит вам использовать этот код в разных местах:

    
    // Clearfix
    @mixin clearfix {
      &:after {
        display: table;
        clear: both;
        content: '';
      }
    }
    
    // Usage
    .three-col-grid { @include clearfix; }
    
После того как мы закончили с колонками, следующим шагом создадим несколько 
отступов.

## Шаг 5: Определите расположение отступов {#шаг-5-определите-распложение-отступов}

Итак, мы знаем, что должны создать отступы либо со свойством `margin`, либо 
со свойством `padding`. Но что мы должны использовать?

Сделав несколько набросков, вы быстро поймете, что у вас есть четыре возможных
способа как сделать эти отступы.

1.  Отступы могут быть расположены *с одной стороны*, в виде *внешних отступов* 
2.  Отступы могут быть расположены *с одной стороны*, в виде *внутренних отступов* 
3.  Отступы могут быть расположены равномерно *с обоих сторон*, 
в виде *внешних отступов* 
4.  Отступы могут быть расположены равномерно *с обоих сторон*,
в виде *внутренних отступов*<figure>

![4 возможных способа создать колонки и отступы][15]<figcaption>4 возможных способа 
создать колонки и отступы</figcaption></figure>

Здесь начинаются сложности. Вам нужно рассчитать ширину колонок по-разному,
в зависимости от используемого метода.

Мы рассмотрим эти методы один за другим и посмотрим на разницу. Не торопитесь, пока
вы читаете о них.

Поехали:

### Метод 1: Односторонние отступы (внешние)

Используя этот метод, вы создаете отступы при помощи свойства `margin`. Этот
отступ будет расположен слева или справа от колонки. Вам решать какую 
сторону выбрать.

В рамках этой статьи, давайте предположим, что вы задаете свои отступы справа. 
Вот что вы будете делать:

    .grid-item {
      /* Need to recalculate width property */;
      margin-right: 20px;
      float: left;
    }
    

Затем, вы пересчитываете ширину колонки как на этой картинке:<figure>

![Односторонние отступы с использованием внешних отступов][16]<figcaption>Односторонние 
отступы с использование внешних отступов</figcaption></figure>
Как вы видите на картинке выше, *1440px* равняются *трем колонкам* и *двум отступам*.

И тут у нас появилась проблема... Нам нужно, что бы колонки были описаны в процентах,
но в тоже время наши отступы зафиксированы на ширине 20px. Мы не можем делать вычисления с
двумя разными единицами измерения одновременно!

Ну, это было невозможно раньше, но возможно сейчас.

Вы можете использовать CSS-функцию `calc` для сочетания процентов с другими 
единицами. Она на лету извлекает значение процентов для вычислений.

Это значит, что вы можете задать ширину в виде функции, и браузер автоматически
рассчитает для вас ее значение:

    .grid-item {
      width: calc((100% - 20px * 2) / 3);
      /* other properties */
    }
    

Это отлично.

После получения ширины колонки, вам нужно удалить последний отступ у крайнего 
правого элемента сетки. Вот как вы можете сделать это:

    .grid-item:last-child {
      margin-right: 0;
    }
    
Чаше всего, когда вы удаляете последний отступ у крайнего правого элемента, вы
также хотите задать ему обтекание по правой стороне для предотвращения ошибок
субпикселного округления, из-за которых ваша сетка переносит последний элемент 
на новую строку. Это происходит только в браузерах, которые округляют пикселы.
<figure>

![Ошибка субпикселного округления может сломать сетку, вытолкнув последний элемент на следующую строку][17]<figcaption>
Ошибка субпикселного округления может сломать сетку, вытолкнув 
последний элемент на следующую строку</figcaption></figure>
    
    .grid-item:last-child {
      margin-right: 0;
      float: right;
    }

Фух. Почти готово. Еще одна вещь.

Наш код хорош только в том случае, если сетка содержит только одну строку.  
Однако, он не обрезает их, если строк с элементами больше чем одна :cry:<figure>

![Наш код лажает, если строк больше чем одна][18]<figcaption>Наш код лажает,
если строк больше чем одна</figcaption></figure>

Нам нужно удалить правый внешний отступ у каждого крайнего правого
элемента в каждой строке. Лучше способа сделать это - использовать `nth-child()`:

    
    /* For a 3-column grid */
    .grid-item:nth-child(3n+3) {
      margin-right: 0;
      float: right;
    }
    

Это все, что вам нужно для создания односторонних внешних отступов.
Вот codepen, что бы вы могли поиграться с этим.

See the Pen [Односторонняя сетка с использованием внешних отступов][19] by Zell Liew 
([@zellwk][20]) on [CodePen][21].

Примечание: Свойство Calc не работает в IE8 и Opera mini. Вы можете посмотреть
другие методы, если вам нужно поддерживать эти два браузера.

### Метод 2: Односторонние отступы (внутренние)

Как и с односторонними внешними отступами, в этот методе требуется разместить ваши
отступы на одной из сторон ваших колонок. Предположим, что вы снова выбрали правую
сторону.

    .grid-item {
      /* width property */
      padding-right: 20px;
      float: left;
    }
    
Затем, вы можете пересчитать ширину колонки как на этой 
картинке:<figure>

![Односторонние отступы с использованием внутренних отступов][22]<figcaption>Односторонние 
отступы с использованием внутренних отступов</figcaption></figure>

Обратили внимание, что ширина отличается от предыдущего метода?
Она отличается, потому что мы переключили свойство `box-sizing` в `border-box`.
Теперь `width` рассчитывается, включая в себя `padding`.

В этом случае, две из трех колонок имеют бОльшую ширину, чем последняя, что
в конечном итоге приводит к причудливым расчетам и делает CSS код трудным для понимания.

Я предлагаю даже не пробовать этот методом. (Оно станет действительно уродливым, если
вы продолжите с ним. Пробуйте на свой страх и риск.) 

### Метод 3: Разделенные отступы (внешние) {#method-3-split-gutters-margin-}

В этом методе, вы разделяете отступы на две части и размещаете по половине с 
каждой стороны ваших колонок. Код выглядит примерно так:


    .grid-item {
      /* Width property */
      margin-right: 10px;
      margin-left: 10px;
      float: left;
    }
    

Затем, вы пересчитываете ширину колонки как на этой картинке:<figure>

![Разделение внешних отступов][23]<figcaption>
Разделение внешних отступов</figcaption></figure>

Как мы узнали ранее, вам нужно рассчитать ширину колонки с помощью 
функции `calc()`. В этой ситуации, вы отнимаете три отступа от 100%,
прежде чем делить ответ на три для получения ширины колонки. Другими словами,
ширина колонки будет `calc((100% - 20px * 3) / 3)`.

    .grid-item {
      width: calc((100% - 20px * 3) / 3);
      margin-right: 10px;
      margin-left: 10px;
      float: left;
    }
    

Это все! (Вам не нужно ничего дополнительно делать для сеток с несколькими строками :wink:).
Вот codepen, что бы вы могли поиграться с этим:

See the Pen [Сетка с внешними разделенными отступами][24] by Zell Liew (
[@zellwk][20]) on [CodePen][21].

### Метод 4: Разделенные отступы (внутренние) {#method-4-split-gutters-padding-}

Этот метод аналогичен предыдущему. Вы делили ваши отступы и размещаете их с каждой 
стороны ваших колонок. На этот раз, вы используете внутренние отступы:

    .grid-item {
      /* width property */
      padding-right: 10px;
      padding-left: 10px;
      float: left;
    }
    

Затем, вы рассчитываете ширину вашей колонки так:<figure>

![Разделенные внутренние отступы][25]<figcaption>Разделенные внутренние 
отступы</figcaption></figure>

Обратили внимание, что в этот раз гораздо легче делать расчеты?
Все верно; это треть ширины сетки в каждой контрольной точке.

    .grid-item {
      width: 33.3333%;
      padding-right: 10px;
      padding-left: 10px;
      float: left;
    }
    

Вот codepen, что бы вы могли поиграться с этим:

See the Pen [Сетка с внутренними разделенными  отступами][26] by Zell Liew (
[@zellwk][20]) on [CodePen][21].

Прежде чем мы двинемся дальше, я хочу сказать вам о небольшом предостережении,
если вы используете разделенные внутренние отступы. Если вы взгляните на разметку в
Codepen, то вы увидите, что я добавил дополнительный `<div>` внутри `.grid-item`. 
Этот дополнительный `<div>` важен, если ваш компонент содержит фон или границы.

Это потому что фон отображается на внутренних границах. Эта картинка должна
объяснить почему (я надеюсь), показав связь между `background` и другими 
свойствами.<figure>

![Фон отображается на внутренних границах][27]<figcaption>Фон отображается 
на внутренних границах</figcaption></figure>


### Что бы я использовал? {#что-бы-я-использовал}

Когда я начинал кодить сетки два года назад, я в основном делал сетки, которые
были спроектированы по [нисходящему подходу][28] и построены на 
 [гибридной системе][29]. В таком подходе/системе, *я использовал процентные значения*
 *и для ширины, и для отступов*

В то время, я любил простоту настроек отступов с одной стороны колонки. Это было менее 
напряжно для меня, потому что я довольно плох в математике. Дополнительные 
`отступы / 2` расчеты быстро вырубали меня.

Я благодарен, что я пошел этим путем. Хоть CSS и выглядит более сложным, чем
для разделенных отступов, я был вынужден изучить [свойство nth-child][30]. Я также
понял важность написания [CSS сперва для мобильных][31]. Насколько я могу судить, 
это до сих пор является главным препятствием и для молодых, и для опытных
разработчиков.

Так или иначе, если вы попросите меня выбрать сейчас, **я выберу разделенные отступы**
вместо односторонних, потому что CSS для них более простой. Также, 
**я рекомендую использовать внешние отступы**  вместо внутренних, потому что 
разметка получается чище. (Но *внутренние отступы легче рассчитать*, поэтому я продолжу 
статью с внутренними отступами).

## Шаг 6: Создайте отладочную сетку {#шаг-6-создайте-отладочную-сетку}

Когда вы только начинаете, особенно полезно иметь под рукой контрольную сетку,
которая поможет вам отладить вашу разметку. Это помогает быть уверенным, что
вы все делаете правильно.

На данный момент, я знаю только кривой способ создать отладочную сетку. Нужно
создать HTML-элементы и добавить к ним немного CSS. Вот так примерно выглядит HTML:

    <div class="fixed-gutter-grid">
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
    </div>
    

CSS для отладочной сетки будет следующий (я использую разделенные внешние отступы
для упрощения разметки отладочной сетки):


    .column {
      width: calc((100% - 20px * 12) / 12);
      height: 80px;
      margin-right: 10px;
      margin-left: 10px;
      background: rgba(0, 0, 255, 0.25);
      float: left;
    }
    

See the Pen [Отладочная сетка с фиксированными отступами][32] by Zell Liew ([@zellwk][20]) on 
[CodePen][21].

(Ультра ремарка: Сьюзан Мириам (Suzanne Miriam) and Собрал Робсон (Sobral Robson) работают
над [фоновым SVG изображением отладочной сетки для Susy v3][33]. Это мега захватывающе,
потому что вы можете использовать простую функцию для создания вашей отладочной сетки!)


## Шаг 7: Внесите изменения в раскладку {#шаг-7-внесите-изменения-в-раскладку}

Следующий шаг заключается во внесении изменений в вашу раскладку на основе 
вашего контента. Это то, где CSS-сетка сияет. Вместо того, что бы создавать 
раскладку с написанием множества сеточных классов, вы можете создать для нее
разумно-звучащее имя.
 
Для примера, давайте допустим, что у вас есть сетка для раскладки, которая
используется только для гостевых статей. Для десктопа раскладка выглядит 
примерно так:<figure>

![Пример сетки для раскладки, которая используется только для гостевых статей][34]<figcaption>
Пример сетки для раскладки, которая используется только для гостевых статей</figcaption></figure>

Разметка для раскладки этой гостевой статьи может быть такой:

    div class="l-guest-article">
      <div class="l-guest"> <!-- Guest profile --></div>
      <div class="l-main"><!-- main article--></div>
      <div class="l-sidebar"><!-- sidebar widgets--></div>
    </div>
    

Хорошо, дорогуша. Итак, сейчас у нас есть 12 колонок. Ширина одной колонки 8.333% 
`(100 / 12)`.

Ширина `.l-guest` равна двум колонкам. Так что, что вам нужно сделать, так это умножить
8.333% на два. Достаточно просто. Просто прополоскайте и повторите для остального.

Здесь я предлагаю использовать препроцессор типа Sass, который позволит вам рассчитывать
ширину колонок проще, использую функцию `percentage`, заместо ручных расчетов:

    .l-guest-article {
      @include clearfix;
      .l-guest {
        // Ahem. More readable than 16.666% :)
        width: percentage(2/12);
        padding-left: 10px;
        padding-right: 10px;
        float: left;
      }
    
      .l-main {
        width: percentage(7/12);
        padding-right: 10px;
        padding-left: 10px;
        float: left;
      }
    
      .l-sidebar {
        width: percentage(3/12);
        padding-right: 10px;
        padding-left: 10px;
        float: left;
      }
    }
    

See the Pen [Сетка с фиксированными отступами для раскладки гостевой статьи][35] by Zell Liew
([@zellwk][20]) on [CodePen][21].

Вы должно быть заметили, что сейчас часть кода повторяется. Мы можем сделать его
лучше, вынеся общие части в отдельный селектор типа `.grid-item`.

    .grid-item {
      padding-left: 10px;
      padding-right: 10px;
      float: left;
    }
    
    .l-guest-article {
      .l-guest { width: percentage(2/12);}
      .l-main { width: percentage(7/12);}
      .l-sidebar { width: percentage(3/12); }
    }
    

Вот так. Гораздо чище. :)

## Шаг 8: сделайте вашу раскладку адаптивной {#шаг-8-сделайте-вашу-раскладку-адаптивноой}

Последний шаг - это сделать вашу раскладку адаптивной.
Давайте предположим, что раскладка нашей гостевой статьи ведет себя 
следующим образом:<figure>

![Как раскладка гостевой статьи ведет себя на различных вьюпортах][36]<figcaption>
Как раскладка гостевой статьи ведет себя на различных вьюпортах</figcaption></figure>

Разметка нашей гостевой статьи не должна меняться. То, что у нас есть - это 
самая доступная раскладка, которая у нас может быть. Так что, изменения должны
быть полностью в CSS.

При написании CSS для нашей отзывчивой гостевой раскладки, я настоятельно рекомендую
вам писать [CSS сперва для мобильных][37], потому что это делает ваш код проще и 
аккуратнее. В первую очередь, мы можем начать писать CSS для мобильной раскладки.

Вот код:

    .l-guest-article {
      .l-guest { /* nothing goes here */ }
      .l-main {
        margin-top: 20px;
      }
      .l-sidebar {
        margin-top: 20px;
      }
    }
    
Нам здесь нечего делать, т.к. каждый компонент занимает всю доступную ширину по
умолчанию. Однако, мы можем добавить верхний отступ к последним двум элементам,
что бы отделить их друг от друга.

Далее, давайте двигаться к планшетной раскладке. 

Давайте предположим, что для этой раскладки мы установим контрольную точку в
700px. `.l-guest` должен занимать 4 из 12 колонок, в то время как
`.l-main` и `.l-sidebar` должны занимать по 8 колонок каждый.

Здесь нам надо удалить свойство `margin-top` у `.l-main`, потому что он должен 
быть на одной линии с `.l-guest`.

Также, если мы выставляем `.l-sidebar` в ширину 8 колонок, то он автоматически
перейдет во второй ряд, т.к. в первом ряду не достаточно места. Т.к. он находится
во втором ряду, нам также надо добавить внешний отступ слева у `.l-sidebar`, что бы
протолкнуть его на позицию; в качестве альтернативы, мы можем сделать его 
обтекаемым справа. (я добавлю обтекание справа, т.к. нет необходимости что-либо
высчитывать).

Наконец, т.к. мы сделали нашу сетку обтекаемой, контейнер сетки должен включать
в себя clearfix, что бы очистить обтекание у дочерних элементов.

    .l-guest-article {
      @include clearfix;
      .l-guest {
        @media (min-width: 700px) {
          width: percentage(4/12);
          float: left;
        }
      }
      .l-main {
        margin-top: 20px;
        @media (min-width: 700px) {
          width: percentage(8/12);
          margin-top: 0;
          float: left;
        }
      }
      .l-sidebar {
        margin-top: 20px;
        @media (min-width: 700px) {
          width: percentage(8/12);
          float: right;
        }
      }
    }
    

И наконец, давайте перейдем к настольной раскладке. 

Давайте предположим, что для этой раскладки мы установим контрольную точку
в 1200px. `.l-guest` должен занимать 2 из 12 колонок,`.l-main` должен
занимать 7 из 12 колонок, и `.l-sidebar` должен занимать 3 из 12 колонок.

Что мы делаем, так это создаем новый медиа запрос в рамках каждого элемента
сетки и изменяем ширину по необходимости. Обратите внимание, что мы 
также должны удалить верхний отступ у `.l-sidebar`


    .l-guest-article {
      @include clearfix;
      .l-guest {
        @media (min-width: 700px) {
          width: percentage(4/12);
          float: left;
        }
    
        @media (min-width: 1200px) {
          width: percentage(2/12);
        }
      }
      .l-main {
        margin-top: 20px;
        @media (min-width: 700px) {
          width: percentage(8/12);
          margin-top: 0;
          float: left;
        }
        @media (min-width: 1200px) {
          width: percentage(7/12);
        }
      }
      .l-sidebar {
        margin-top: 20px;
        @media (min-width: 700px) {
          width: percentage(8/12);
          float: right;
        }
        @media (min-width: 1200px) {
          width: percentage(3/12);
          margin-top: 0;
        }
      }
    }
    

Вот codepen с финальной раскладкой, которую мы создали:

See the Pen [Сетка с фиксированными отступами для раскладки гостевой статьи (финальная версия)][38] 
by Zell Liew ([@zellwk][20]) on [CodePen][21].

(О, кстати, вы также можете добиться таких результатов со Susy.
Только не забудьте выставить [gutter-position][39] в `inside-static`).

## В завершении {#в-завершении}

Ух. Это длинная статья. Я думал, что трижды умру, пока пишу ее. (Спасибо,
что дочитали до сюда. Я надеюсь, вы не умерли трижды, пока читали ее! :stuck_out_tongue:).

Как вы можете увидеть в этой статье, шаги для создания отзывчивой сетки относительно
просты. Этапами, которые запутывают большинство людей, 
являются шаги 5 (определите положение отступов) и 8 (сделайте вашу раскладку
адаптивной).

Шаг 5 прост, когда вы знаете все возможные методы, а мы разбирали их вместе.
Шаг 8, с другой стороны, легко разрешим, когда у вас есть достаточно опыта
в написании [CSS сперва для мобильных][37].

Я надеюсь эта статья дала вам знания для построения вашей собственной 
отзывчивой сетки, и я надеюсь увидеть вашу специально созданную сетку для 
вашего следующего проекта.

До скорого!</article>

 [1]: https://zellwk.com/blog/designing-grids
 [2]: https://zellwk.com/blog/designing-grids/
 [3]: https://zellwk.com/blog/migrating-from-bootstrap-to-susy/
 [4]: https://zellwk.com/blog/from-html-grids-to-css-grids/
 [5]: http://gridbyexample.com
 [6]: img/box-sizing.jpg
 [7]: https://zellwk.com/blog/understanding-css-box-sizing/
 [8]: https://smacss.com
 [9]: https://twitter.com/snookca
 [10]: img/columns.png
 [11]: img/grid-break.gif
 [12]: img/grid-columns.gif
 [13]: https://css-tricks.com/all-about-floats/
 [14]: img/float-collapse.png
 [15]: img/combi.png
 [16]: img/pattern-1side-margin.png
 [17]: img/subpixel.png
 [18]: img/margin-side-last-child.png
 [19]: http://codepen.io/Lesnevskiy/pen/RoZpva
 [20]: http://codepen.io/Lesnevskiy
 [21]: http://codepen.io
 [22]: img/pattern-1side-gutter.png
 [23]: img/pattern-split-margin.png
 [24]: http://codepen.io/Lesnevskiy/pen/KNvWYR
 [25]: img/pattern-split-padding.png
 [26]: http://codepen.io/Lesnevskiy/pen/qqXrzB
 [27]: img/bg-relationship.jpg
 [28]: https://zellwk.com/blog/designing-grids/#how-big-should-columns-and-gutters-be-
 [29]: https://zellwk.com/blog/designing-grids/#how-the-grid-responds-to-different-viewports
 [30]: https://css-tricks.com/examples/nth-child-tester/
 [31]: https://zellwk.com/blog/how-to-write-mobile-first-css/
 [32]: http://codepen.io/Lesnevskiy/pen/RoZVbG
 [33]: https://github.com/oddbird/susy/issues/609
 [34]: img/grid-example.png
 [35]: http://codepen.io/Lesnevskiy/pen/QGMvLm
 [36]: img/grid-responsive.png
 [37]: https://zellwk.com/blog/mobile-first-css/
 [38]: http://codepen.io/Lesnevskiy/pen/zodwOQ
 [39]: https://zellwk.com/blog/susy-gutter-positions/
