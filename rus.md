<article>
Кастомная отзывчивая сетка - один из лучших инструментов для создания уникального дизайна.
Вы можете настроить всё, что нужно - количество и ширину колонок, отступы и даже контрольные точки, 
при достижении которых перестраивается раскладка страницы.

К сожалению, большинство людей не использует кастомные системы сеток из-за того, что им не хватает знаний и уверенности в своих силах.

В этой статье я хочу помочь вам обрести знания и веру в себя, они 
вам определенно понадобятся для создания собственной сетки. Надеюсь, что к концу этой статьи
вы отложите фреймворки и попробуете создать собственную сетку в следующем
проекте.

## Что входит в сетку? {#что-входит-в-сетку}

Прежде всего, вам нужно знать три вещи.

**Во-первых, вам нужно спроектировать сетку.**

Вы используете колонки одинаковой или разной ширины? Сколько у вас колонок?
Какая ширина и отступы у колонок?

Вы сможете правильно просчитать параметры сетки только после того, как ответите
на эти вопросы. Чтобы помочь вам, я написал статью о [проектировании сеток][1].
Прочтите её, что бы научиться грамотно проектировать сетки.

**Во-вторых, вам нужно знать, как ваша сетка должна вести себя на экранах разного размера.**

Будете ли вы менять размеры колонок и отступов пропорционально ширине экрана или будете 
менять только ширину колонок, оставляя отступы фиксированными? А может менять
количество колонок в конкретных контрольных точках?

На эти вопросы тоже нужно ответить. Они подскажут вам, как рассчитать ширину колонок
и отступов. Если у вас возникли сомнения, прочтите [статью о проектировании сеток][2].

**В-третьих, понравится ли вам писать классы сетки в разметке?**

Когда заходит речь о сетках, мир фронтенда делится на две фракции.

Одни пишут классы сетки в разметке (такой подход используется, например,
в Bootstrap и Foundation). Я называю это **HTML-сетками**. Их разметка выглядит так: 

    <div class="container">
      <div class="row">
        <div class="col-md-9">Content</div>
        <div class="col-md-3">Sidebar</div>
      </div>
    </div>

Другие создают сетки на CSS. Я называю это **CSS-сетки**.

С CSS-сетками разметка получается проще, чем с HTML-сетками.
Вам не приходится повторяться, размечая визуально похожие части документа.
Также вам не нужно помнить, какие у сетки классы:

    <div class="content-sidebar">
      <div class="content"></div>
      <div class="sidebar"></div>
    </div>

С другой стороны, стили в случае с CSS-сетками получаются сложнее.
Нужно хорошенько подумать даже для реализации простой задачи 
(если раньше вы таких сеток не создавали).

**Что бы я выбрал?**

Я, как и многие эксперты фронтенда, выбираю CSS-сетки
(но я не смею называть себя экспертом).

Если вам интересно, я написал [статью][3] о том, почему я выбрал
CSS-сетки вместо HTML-сеток. Также я написал [статью][4],
которая поможет вам перейти с HTML-сеток на CSS-сетки.

(Так много статей читать... :cry:)


В любом случае, вам нужно определиться с тремя вещами,
прежде чем создавать свою сетку. В целом, вот они:

1.  Дизайн сетки
2.  Как сетка ведет себя на разных вьюпортах
3.  Что использовать - CSS-сетку или HTML-сетку?


Мы можем двигаться дальше, только определившись с этими вещами.
В этой статье условия таковы:

1.  Сетка имеет максимальную *ширину в 1140px*, с *12 колонками по 75px* и 
    *отступами в 20px*. (Прочтите [эту статью][2] с советами о том, 
    как получить эти числа)
2.  Когда вьюпорт меняет размеры, колонки должны менять размеры пропорционально,
    в то время как *отступы остаются фиксированными* с шириной 20px. 
    (Прочтите [эту статью][2], что бы понять, почему я выбрал такое поведение).
3.  Я собираюсь создавать *CSS-сетку*. (Прочтите [эту статью][3], 
    что бы понять, почему я рекомендую такой подход).

Итак, давайте начнём!

## Создаем вашу сетку {#создаем-вашу-сетку}

Есть восемь шагов для того, что бы построить сетку. Вот эти шаги: 

1.  Выберите спецификацию для сетки
2.  Установите `box-sizing` в `border-box` 
3.  Создайте контейнер для сетки
4.  рассчитайте ширину колонок
5.  Определите расположение отступов
6.  Создайте сетку для отладки
7.  Внесите изменения в раскладку
8.  Сделайте вашу раскладку адаптивной

Большинство из этих шагов становятся достаточно простыми, как только
вы сделаете их хотя бы раз. Я обстоятельно объясню все, что вам нужно знать 
на каждом шаге.

## Шаг 1: Выберите спецификацию {#шаг-1-выберите-спецификацию}

Вы используете *CSS Grid*, *Flexbox*, или старые добрые *флоаты* в вашей сетке?
Ваши инструкции и детали реализации будут различаться для каждой спецификации.

Из всех трех спецификаций, CSS Grid на сегодняшний день является лучшим инструментов 
для создания сетки (из-за сетки :sunglasses:). К сожалению, поддержка CSS Grid 
оставляет желать лучшего, и мы не можем использовать его прямо сейчас. 
Каждый браузер прячет CSS Grid Layout под флаг, и это значит,
что мы не будет рассматривать его в статье. Я настоятельно рекомендую посмотреть
[работу Рейчел Эндрю (Rachel Andrew)][5], если вам интересен CSS Grid.

Далее, перейдем к Flexbox и флоатам. Инструкции при использовании этих двух
спецификаций похожи, так что вы можете выбрать любую из них и читать статью дальше.
Я буду использовать флоаты, потому что их проще объяснить и они лучше
подходят для новичков.

Если вы выбрали Flexbox, имейте ввиду, что есть несколько нюансов, которые вам 
нужно учесть.

## Шаг 2: Установите box-sizing в border-box {#шаг-2-установите-box-sizing-в-border-box}

Свойство `box-sizing` меняет дефолтные настройки блочной CSS модели, которая
используется браузерами для расчета свойств `width` и `height`. Выставляя `box-sizing`
в `border-box`, мы сильно упрощаем расчет размеров колонок и отступов
(вы увидите это позже).

Вот картинка, которая демонстрирует как `width` вычисляется в зависимости от значений
`box-sizing`<figure>

![Свойство Box-sizing и как оно влияет на расчет ширины][6]<figcaption>
Свойство Box-sizing и как оно влияет на расчет ширины</figcaption></figure>

Обычно я ставлю `box-sizing` в `border-box` для всех элементов на сайте, 
так что расчеты `width` и `height` остаются последовательными (и интуитивно понятными)
по всем направлениям. Вот как я делаю это:

    html {
      box-sizing: border-box;
    }
    
    *,
    *:before,
    *:after {
      box-sizing: inherit;
    }

Примечание: если вам нужно более детальное объяснение `box-sizing`, я рекомендую
вам [прочесть эту статью][7].


## Шаг 3: Создайте контейнер для сетки {#шаг-3-создайте-контейнер-для-сетки}

У каждой сетки есть контейнер, определяющий её максимальную ширину. Как правило, я называю его `.l-wrap`. Префикс `.l-` означает layout. Я использую такое название с тех пор, как изучил [SMACSS][8] [Джонатана Снука (Jonathan Snook)][9].

    .l-wrap {
        max-width: 1140px;
        margin-right: auto;
        margin-left: auto;
    }

Примечание: для лучшей доступности и отзывчивости настоятельно рекомендую использовать относительные единицы измерения типа `em` или `rem` вместо пикселей. В этой статье пишу все в `px`, потому что так проще для понимания.

## Шаг 4: Расcчитайте ширину колонок {#шаг-4-расчитайте-ширину-колонок}

Помните, что мы используем флоаты. Это значит, что у нас есть только пять свойств для создания наших колонок и отступов(если вы используете Flexbox, то есть еще несколько):

*   width
*   margin-right
*   margin-left
*   padding-right
*   padding-left

Если вы помните, HTML для CSS-сеток выглядит примерно так:
​    
    <div class="l-wrap">
      <div class="three-col-grid">
        <div class="grid-item">Grid item</div>
        <div class="grid-item">Grid item</div>
        <div class="grid-item">Grid item</div>
      </div>
    </div>


В этом HTML сетка имеет всего три колонки в строке и тут нет дополнительных `<div>` для создания отступов. Это означает, что:

1.  Мы создаем колонки со свойством `width`
2.  Мы создаем отступы либо со свойством `margin`, либо со свойством `padding`

Думать о колонках и отступах одновременно сложно, так что давайте предположим, что сперва создаем сетку без отступов.

На выходе такая сетка будет похожа на что-то такое:<figure>

![Трех-колоночная сетка без отступов][10]<figcaption>Трех-колоночная сетка без отступов</figcaption></figure>

Настал момент, когда необходимо сделать немного математических вычислений. Мы знаем, что сетка имеет максимальную ширину в 1140px, значит каждая колонка будет 380px (`1140 ÷ 3`).

    .three-col-grid .grid-item {
      width: 380px;
      float: left;
    }


Пока все хорошо. Мы сделали сетку, которая отлично работает на вьюпортах больше чем 1140px. К сожалению, все ломается, когда вьюпорт становится меньше.<figure>

![Сетка ломается, когда вьюпорт меньше 1140px][11]<figcaption>Сетка ломается, когда вьюпорт меньше 1140px</figcaption></figure>

Это значит, что мы не можем использовать пиксели в наших расчетах. Нам нужна единица измерения, которая сможет перестроиться в соответствии с шириной контейнера - проценты (`%`). Поэтому, пропишем ширину в процентах:

    .three-col-grid .grid-item  {
      width: 33.33333%;
      float: left;
    }

Полученный выше код - это простая трех-колоночная сетка без каких-либо отступов. Когда браузер меняет размер, эти три колонки пропорционально изменяются в размере.<figure>

![Три колонки без отступов][12]<figcaption>Три колонки без отступов</figcaption></figure>

Еще кое-что, перед тем как мы двинемся дальше. Всякий раз, когда все дочерние элементы в контейнере имеют обтекание, высота контейнера схлопывается. Этот феномен называется [схлопывание флоата][13]. Это как если бы в контейнере не было бы никаких дочерних элементов:<figure>

![Схлопывание флоата. Изображение с CSS Tricks][14]<figcaption>Схлопывание 
флоата (изображение с CSS Tricks)</figcaption></figure>

Для того, что бы это исправить, нам нужен clearfix, который выглядит следующим образом:

    .three-col-grid:after {
      display: table;
      clear: both;
      content: '';
    }

Если вы используете препроцессор вроде Sass, вы можете сделать примесь,
которая позволит вам использовать этот код в разных местах:

    // Clearfix
    @mixin clearfix {
      &:after {
        display: table;
        clear: both;
        content: '';
      }
    }
    
    // Usage
    .three-col-grid { @include clearfix; }

После того как мы закончили с колонками, следующим шагом создадим несколько отступов.

## Шаг 5: Определите расположение отступов {#шаг-5-определите-распложение-отступов}

Итак, мы знаем, что должны создать отступы либо со свойством `margin`, либо со свойством `padding`. Но что использовать?

Сделав несколько набросков, вы быстро поймете, что есть четыре возможных способа как сделать эти отступы. Отступы могут быть расположены:

1.  *с одной стороны*, в виде *внешних отступов* 
2.  *с одной стороны*, в виде *внутренних отступов* 
3.  равномерно *с обоих сторон*, в виде *внешних отступов* 
4.  равномерно *с обоих сторон*, в виде *внутренних отступов*<figure>

![4 возможных способа создать колонки и отступы][15]<figcaption>4 возможных способа создать колонки и отступы</figcaption></figure>

Здесь начинаются сложности. Вам нужно по-разному рассчитать ширину колонок
в зависимости от используемого метода.

Рассмотрим эти методы один за другим и посмотрим на разницу. Не торопитесь, пока вы читаете о них.

Поехали:

### Метод 1: Односторонние отступы (внешние)

Используя этот метод, вы создаете отступы при помощи свойства `margin`. Этот отступ будет расположен слева или справа от колонки. Вам решать какую сторону выбрать.

В рамках этой статьи, давайте предположим, что вы задаете отступы справа. Вот что вы будете делать:

    .grid-item {
      /* Need to recalculate width property */;
      margin-right: 20px;
      float: left;
    }


Затем пересчитываете ширину колонки как на картинке:<figure>

![Односторонние отступы с использованием внешних отступов][16]<figcaption>Односторонние отступы с использование внешних отступов</figcaption></figure>
Как вы видите на картинке выше, *1440px* это *три колонки* и *два отступа*.

И тут появляется проблема... Нам нужно, чтобы колонки были описаны в процентах, но в то же время отступы зафиксированы на ширине 20px. Мы не можем делать вычисления с двумя разными единицами измерения одновременно!

Это было невозможно раньше, но возможно сейчас.

Вы можете использовать CSS-функцию `calc` для сочетания процентов с другими единицами измерения. Она «на лету» извлекает значение процентов для выполнения вычислений.

Это значит, что вы можете задать ширину в виде функции, и браузер автоматически рассчитает ее значение:

    .grid-item {
      width: calc((100% - 20px * 2) / 3);
      /* other properties */
    }


Это круто.

После получения ширины колонки, вам нужно удалить последний отступ у крайнего правого элемента сетки. Вот как это можно сделать:

    .grid-item:last-child {
      margin-right: 0;
    }

Чаще всего, когда вы удаляете последний отступ у крайнего правого элемента, вы также хотите задать ему обтекание по правой стороне для предотвращения ошибок субпикселного округления, из-за которых ваша сетка переносит последний элемент на новую строку. Это происходит только в браузерах, которые округляют пикселы.
<figure>

![Ошибка субпикселного округления может сломать сетку, вытолкнув последний элемент на следующую строку][17]<figcaption>
Ошибка субпикселного округления может сломать сетку, вытолкнув последний элемент на следующую строку</figcaption></figure>
​    
    .grid-item:last-child {
      margin-right: 0;
      float: right;
    }

Фух. Почти готово. И еще одна вещь.

Наш код хорош только в том случае, если сетка содержит лишь одну строку. Однако, он не обрезает их, если строк с элементами больше чем одна :cry:<figure>

![Наш код лажает, если строк больше чем одна][18]<figcaption>Наш код лажает, если строк больше чем одна</figcaption></figure>

Нам нужно удалить правый внешний отступ у каждого крайнего правого элемента в каждой строке. Лучший способ  это сделать - использовать `nth-child()`:


    /* For a 3-column grid */
    .grid-item:nth-child(3n+3) {
      margin-right: 0;
      float: right;
    }

Это все, что нужно для создания односторонних внешних отступов. Вот codepen, что бы вы могли поиграться с этим:

See the Pen [Односторонняя сетка с использованием внешних отступов][19] by Zell Liew ([@zellwk][20]) on [CodePen][21].

Примечание: Свойство Calc не работает в IE8 и Opera mini. Вы можете посмотреть другие методы, если вам необходимо поддерживать эти два браузера.

### Метод 2: Односторонние отступы (внутренние)

Как и с односторонними внешними отступами, в этом методе требуется разместить отступы на одной из сторон колонки. Предположим, что вы снова выбрали правую сторону.

    .grid-item {
      /* width property */
      padding-right: 20px;
      float: left;
    }

Затем, вы можете пересчитать ширину колонки как на картинке:<figure>

![Односторонние отступы с использованием внутренних отступов][22]<figcaption>Односторонние отступы с использованием внутренних отступов</figcaption></figure>

Обратили внимание, что ширина отличается от предыдущего метода? Мы переключили свойство `box-sizing` в `border-box`. Теперь `width` рассчитывается, включая в себя `padding`.

В этом случае, две из трех колонок имеют бОльшую ширину, чем последняя, что в конечном итоге приводит к причудливым расчетам и делает CSS код трудным для понимания.

Я предлагаю даже не продолжать этот метод. (Он станет действительно уродливым. Пробуйте на свой страх и риск.) 

### Метод 3: Разделенные отступы (внешние) {#method-3-split-gutters-margin-}

В этом методе мы разделяем отступы на две части и размещаем по половине с каждой стороны колонки. Код выглядит примерно так:


    .grid-item {
      /* Width property */
      margin-right: 10px;
      margin-left: 10px;
      float: left;
    }


Затем пересчитываем ширину колонки как на картинке:<figure>

![Разделение внешних отступов][23]<figcaption>Разделение внешних отступов</figcaption></figure>

Как мы узнали ранее, рассчитать ширину колонки можно с помощью функции `calc()`. В данной ситуации мы отнимаем три отступа от 100%, прежде чем делить ответ на три для получения ширины колонки. Другими словами, ширина колонки будет `calc((100% - 20px * 3) / 3)`.

    .grid-item {
      width: calc((100% - 20px * 3) / 3);
      margin-right: 10px;
      margin-left: 10px;
      float: left;
    }


Это все! (Вам не нужно ничего дополнительно делать для сеток с несколькими строками :wink:).
Вот codepen, что бы вы могли поиграться с этим:

See the Pen [Сетка с внешними разделенными отступами][24] by Zell Liew (
[@zellwk][20]) on [CodePen][21].

### Метод 4: Разделенные отступы (внутренние) {#method-4-split-gutters-padding-}

Этот метод аналогичен предыдущему. Мы делили отступы и размещали их с каждой стороны колонки. На этот раз мы используем внутренние отступы:

    .grid-item {
      /* width property */
      padding-right: 10px;
      padding-left: 10px;
      float: left;
    }


Затем вы рассчитываете ширину колонки так:<figure>

![Разделенные внутренние отступы][25]<figcaption>Разделенные внутренние отступы</figcaption></figure>

Обратили внимание, что в этот раз гораздо легче делать расчеты? Все верно; это треть ширины сетки в каждой контрольной точке.

    .grid-item {
      width: 33.3333%;
      padding-right: 10px;
      padding-left: 10px;
      float: left;
    }


Вот codepen, что бы вы могли поиграться с этим:

See the Pen [Сетка с внутренними разделенными  отступами][26] by Zell Liew (
[@zellwk][20]) on [CodePen][21].

Прежде чем мы двинемся дальше, я хочу вас предостеречь, если вы используете разделенные внутренние отступы. Если вы взгляните на разметку в Codepen, то увидите, что я добавил дополнительный `<div>` внутри `.grid-item`.  Этот дополнительный `<div>` важен, если компонент содержит фон или границы.

Это потому что фон отображается на внутренних границах. Эта картинка должна помочь(я надеюсь) разобраться, показав связь между `background` и другими свойствами.<figure>

![Фон отображается на внутренних границах][27]<figcaption>Фон отображается на внутренних границах</figcaption></figure>


### Что бы я использовал? {#что-бы-я-использовал}

Когда я начинал кодить сетки два года назад, я в основном делал сетки, которые
были спроектированы по [нисходящему подходу][28] и построены на 
 [гибридной системе][29]. В таком подходе/системе, *я использовал процентные значения*
 *и для ширины, и для отступов*

В то время, я любил простоту настроек отступов с одной стороны колонки. Это было менее 
напряжно для меня, потому что я довольно плох в математике. Дополнительные 
`отступы / 2` расчеты быстро вырубали меня.

Я благодарен, что я пошел этим путем. Хоть CSS и выглядит более сложным, чем
для разделенных отступов, я был вынужден изучить [свойство nth-child][30]. Я также
понял важность написания [CSS сперва для мобильных][31]. Насколько я могу судить, 
это до сих пор является главным препятствием и для молодых, и для опытных
разработчиков.

Так или иначе, если вы попросите меня выбрать сейчас, **я выберу разделенные отступы**
вместо односторонних, потому что CSS для них более простой. Также, 
**я рекомендую использовать внешние отступы**  вместо внутренних, потому что 
разметка получается чище. (Но *внутренние отступы легче рассчитать*, поэтому я продолжу 
статью с внутренними отступами).

## Шаг 6: Создайте отладочную сетку {#шаг-6-создайте-отладочную-сетку}

Когда вы только начинаете, особенно полезно иметь под рукой контрольную сетку,
которая поможет вам отладить вашу разметку. Это помогает быть уверенным, что
вы все делаете правильно.

На данный момент, я знаю только кривой способ создать отладочную сетку. Нужно
создать HTML-элементы и добавить к ним немного CSS. Вот так примерно выглядит HTML:

    <div class="fixed-gutter-grid">
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
    </div>


CSS для отладочной сетки будет следующий (я использую разделенные внешние отступы
для упрощения разметки отладочной сетки):


    .column {
      width: calc((100% - 20px * 12) / 12);
      height: 80px;
      margin-right: 10px;
      margin-left: 10px;
      background: rgba(0, 0, 255, 0.25);
      float: left;
    }


See the Pen [Отладочная сетка с фиксированными отступами][32] by Zell Liew ([@zellwk][20]) on 
[CodePen][21].

(Ультра ремарка: Сьюзан Мириам (Suzanne Miriam) and Собрал Робсон (Sobral Robson) работают
над [фоновым SVG изображением отладочной сетки для Susy v3][33]. Это мега захватывающе,
потому что вы можете использовать простую функцию для создания вашей отладочной сетки!)


## Шаг 7: Внесите изменения в раскладку {#шаг-7-внесите-изменения-в-раскладку}

Следующий шаг заключается во внесении изменений в вашу раскладку на основе 
вашего контента. Это то, где CSS-сетка сияет. Вместо того, что бы создавать 
раскладку с написанием множества сеточных классов, вы можете создать для нее
разумно-звучащее имя.

Для примера, давайте допустим, что у вас есть сетка для раскладки, которая
используется только для гостевых статей. Для десктопа раскладка выглядит 
примерно так:<figure>

![Пример сетки для раскладки, которая используется только для гостевых статей][34]<figcaption>
Пример сетки для раскладки, которая используется только для гостевых статей</figcaption></figure>

Разметка для раскладки этой гостевой статьи может быть такой:

    div class="l-guest-article">
      <div class="l-guest"> <!-- Guest profile --></div>
      <div class="l-main"><!-- main article--></div>
      <div class="l-sidebar"><!-- sidebar widgets--></div>
    </div>


Хорошо, дорогуша. Итак, сейчас у нас есть 12 колонок. Ширина одной колонки 8.333% 
`(100 / 12)`.

Ширина `.l-guest` равна двум колонкам. Так что, что вам нужно сделать, так это умножить
8.333% на два. Достаточно просто. Просто прополоскайте и повторите для остального.

Здесь я предлагаю использовать препроцессор типа Sass, который позволит вам рассчитывать
ширину колонок проще, использую функцию `percentage`, заместо ручных расчетов:

    .l-guest-article {
      @include clearfix;
      .l-guest {
        // Ahem. More readable than 16.666% :)
        width: percentage(2/12);
        padding-left: 10px;
        padding-right: 10px;
        float: left;
      }
    
      .l-main {
        width: percentage(7/12);
        padding-right: 10px;
        padding-left: 10px;
        float: left;
      }
    
      .l-sidebar {
        width: percentage(3/12);
        padding-right: 10px;
        padding-left: 10px;
        float: left;
      }
    }


See the Pen [Сетка с фиксированными отступами для раскладки гостевой статьи][35] by Zell Liew
([@zellwk][20]) on [CodePen][21].

Вы должно быть заметили, что сейчас часть кода повторяется. Мы можем сделать его
лучше, вынеся общие части в отдельный селектор типа `.grid-item`.

    .grid-item {
      padding-left: 10px;
      padding-right: 10px;
      float: left;
    }
    
    .l-guest-article {
      .l-guest { width: percentage(2/12);}
      .l-main { width: percentage(7/12);}
      .l-sidebar { width: percentage(3/12); }
    }


Вот так. Гораздо чище. :)

## Шаг 8: сделайте вашу раскладку адаптивной {#шаг-8-сделайте-вашу-раскладку-адаптивноой}

Последний шаг - это сделать вашу раскладку адаптивной.
Давайте предположим, что раскладка нашей гостевой статьи ведет себя 
следующим образом:<figure>

![Как раскладка гостевой статьи ведет себя на различных вьюпортах][36]<figcaption>
Как раскладка гостевой статьи ведет себя на различных вьюпортах</figcaption></figure>

Разметка нашей гостевой статьи не должна меняться. То, что у нас есть - это 
самая доступная раскладка, которая у нас может быть. Так что, изменения должны
быть полностью в CSS.

При написании CSS для нашей отзывчивой гостевой раскладки, я настоятельно рекомендую
вам писать [CSS сперва для мобильных][37], потому что это делает ваш код проще и 
аккуратнее. В первую очередь, мы можем начать писать CSS для мобильной раскладки.

Вот код:

    .l-guest-article {
      .l-guest { /* nothing goes here */ }
      .l-main {
        margin-top: 20px;
      }
      .l-sidebar {
        margin-top: 20px;
      }
    }

Нам здесь нечего делать, т.к. каждый компонент занимает всю доступную ширину по
умолчанию. Однако, мы можем добавить верхний отступ к последним двум элементам,
что бы отделить их друг от друга.

Далее, давайте двигаться к планшетной раскладке. 

Давайте предположим, что для этой раскладки мы установим контрольную точку в
700px. `.l-guest` должен занимать 4 из 12 колонок, в то время как
`.l-main` и `.l-sidebar` должны занимать по 8 колонок каждый.

Здесь нам надо удалить свойство `margin-top` у `.l-main`, потому что он должен 
быть на одной линии с `.l-guest`.

Также, если мы выставляем `.l-sidebar` в ширину 8 колонок, то он автоматически
перейдет во второй ряд, т.к. в первом ряду не достаточно места. Т.к. он находится
во втором ряду, нам также надо добавить внешний отступ слева у `.l-sidebar`, что бы
протолкнуть его на позицию; в качестве альтернативы, мы можем сделать его 
обтекаемым справа. (я добавлю обтекание справа, т.к. нет необходимости что-либо
высчитывать).

Наконец, т.к. мы сделали нашу сетку обтекаемой, контейнер сетки должен включать
в себя clearfix, что бы очистить обтекание у дочерних элементов.

    .l-guest-article {
      @include clearfix;
      .l-guest {
        @media (min-width: 700px) {
          width: percentage(4/12);
          float: left;
        }
      }
      .l-main {
        margin-top: 20px;
        @media (min-width: 700px) {
          width: percentage(8/12);
          margin-top: 0;
          float: left;
        }
      }
      .l-sidebar {
        margin-top: 20px;
        @media (min-width: 700px) {
          width: percentage(8/12);
          float: right;
        }
      }
    }


И наконец, давайте перейдем к настольной раскладке. 

Давайте предположим, что для этой раскладки мы установим контрольную точку
в 1200px. `.l-guest` должен занимать 2 из 12 колонок,`.l-main` должен
занимать 7 из 12 колонок, и `.l-sidebar` должен занимать 3 из 12 колонок.

Что мы делаем, так это создаем новый медиа запрос в рамках каждого элемента
сетки и изменяем ширину по необходимости. Обратите внимание, что мы 
также должны удалить верхний отступ у `.l-sidebar`


    .l-guest-article {
      @include clearfix;
      .l-guest {
        @media (min-width: 700px) {
          width: percentage(4/12);
          float: left;
        }
    
        @media (min-width: 1200px) {
          width: percentage(2/12);
        }
      }
      .l-main {
        margin-top: 20px;
        @media (min-width: 700px) {
          width: percentage(8/12);
          margin-top: 0;
          float: left;
        }
        @media (min-width: 1200px) {
          width: percentage(7/12);
        }
      }
      .l-sidebar {
        margin-top: 20px;
        @media (min-width: 700px) {
          width: percentage(8/12);
          float: right;
        }
        @media (min-width: 1200px) {
          width: percentage(3/12);
          margin-top: 0;
        }
      }
    }


Вот codepen с финальной раскладкой, которую мы создали:

See the Pen [Сетка с фиксированными отступами для раскладки гостевой статьи (финальная версия)][38] 
by Zell Liew ([@zellwk][20]) on [CodePen][21].

(О, кстати, вы также можете добиться таких результатов со Susy.
Только не забудьте выставить [gutter-position][39] в `inside-static`).

## В завершении {#в-завершении}

Ух. Это длинная статья. Я думал, что трижды умру, пока пишу ее. (Спасибо,
что дочитали до сюда. Я надеюсь, вы не умерли трижды, пока читали ее! :stuck_out_tongue:).

Как вы можете увидеть в этой статье, шаги для создания отзывчивой сетки относительно
просты. Этапами, которые запутывают большинство людей, 
являются шаги 5 (определите положение отступов) и 8 (сделайте вашу раскладку
адаптивной).

Шаг 5 прост, когда вы знаете все возможные методы, а мы разбирали их вместе.
Шаг 8, с другой стороны, легко разрешим, когда у вас есть достаточно опыта
в написании [CSS сперва для мобильных][37].

Я надеюсь эта статья дала вам знания для построения вашей собственной 
отзывчивой сетки, и я надеюсь увидеть вашу специально созданную сетку для 
вашего следующего проекта.

До скорого!</article>

[1]: https://zellwk.com/blog/designing-grids
[2]: https://zellwk.com/blog/designing-grids/
[3]: https://zellwk.com/blog/migrating-from-bootstrap-to-susy/
[4]: https://zellwk.com/blog/from-html-grids-to-css-grids/
[5]: http://gridbyexample.com
[6]: img/box-sizing.jpg
[7]: https://zellwk.com/blog/understanding-css-box-sizing/
[8]: https://smacss.com
[9]: https://twitter.com/snookca
[10]: img/columns.png
[11]: img/grid-break.gif
[12]: img/grid-columns.gif
[13]: https://css-tricks.com/all-about-floats/
[14]: img/float-collapse.png
[15]: img/combi.png
[16]: img/pattern-1side-margin.png
[17]: img/subpixel.png
[18]: img/margin-side-last-child.png
[19]: http://codepen.io/Lesnevskiy/pen/RoZpva
[20]: http://codepen.io/Lesnevskiy
[21]: http://codepen.io
[22]: img/pattern-1side-gutter.png
[23]: img/pattern-split-margin.png
[24]: http://codepen.io/Lesnevskiy/pen/KNvWYR
[25]: img/pattern-split-padding.png
[26]: http://codepen.io/Lesnevskiy/pen/qqXrzB
[27]: img/bg-relationship.jpg
[28]: https://zellwk.com/blog/designing-grids/#how-big-should-columns-and-gutters-be-
[29]: https://zellwk.com/blog/designing-grids/#how-the-grid-responds-to-different-viewports
[30]: https://css-tricks.com/examples/nth-child-tester/
[31]: https://zellwk.com/blog/how-to-write-mobile-first-css/
[32]: http://codepen.io/Lesnevskiy/pen/RoZVbG
[33]: https://github.com/oddbird/susy/issues/609
[34]: img/grid-example.png
[35]: http://codepen.io/Lesnevskiy/pen/QGMvLm
[36]: img/grid-responsive.png
[37]: https://zellwk.com/blog/mobile-first-css/
[38]: http://codepen.io/Lesnevskiy/pen/zodwOQ
[39]: https://zellwk.com/blog/susy-gutter-positions/
